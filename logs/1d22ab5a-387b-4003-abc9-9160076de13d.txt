====================================================================================================
import os
import sys
with open(sys.argv[0]) as f:
    code = f.read() # read the code of this file ASAP, for logging
import uuid
import glob
import time
from dataclasses import dataclass

import numpy as np
import torch
from torch import nn
import torch.nn.functional as F
import torch.distributed as dist
import torch._inductor.config as config
from torch.nn.parallel import DistributedDataParallel as DDP

# -----------------------------------------------------------------------------
# Muon optimizer

def zeropower_via_svd(G, steps=None):
    U, S, V = G.svd()
    return U @ V.T

@torch.compile
def zeropower_via_newtonschulz5(G, steps=10, eps=1e-7):
    """
    Newton-Schulz iteration to compute the zeroth power / orthogonalization of G. We opt to use a
    quintic iteration whose coefficients are selected to maximize the slope at zero. For the purpose
    of minimizing steps, it turns out to be empirically effective to keep increasing the slope at
    zero even beyond the point where the iteration no longer converges all the way to one everywhere
    on the interval. This iteration therefore does not produce UV^T but rather something like US'V^T
    where S' is diagonal with S_{ii}' \sim Uniform(0.5, 1.5), which turns out not to hurt model
    performance at all relative to UV^T, where USV^T = G is the SVD.
    """
    assert len(G.shape) == 2
    a, b, c = (3.4445, -4.7750,  2.0315)
    X = G.bfloat16()
    X /= (X.norm() + eps) # ensure top singular value <= 1
    if G.size(0) > G.size(1):
        X = X.T
    for _ in range(steps):
        A = X @ X.T
        B = b * A + c * A @ A # adapted from suggestion by @jxbz, @leloykun, and @YouJiacheng
        X = a * X + B @ X
    if G.size(0) > G.size(1):
        X = X.T
    return X

zeropower_backends = dict(svd=zeropower_via_svd, newtonschulz5=zeropower_via_newtonschulz5)

class Muon(torch.optim.Optimizer):
    """
    Muon - MomentUm Orthogonalized by Newton-schulz

    Muon internally runs standard SGD-momentum, and then performs an orthogonalization post-
    processing step, in which each 2D parameter's update is replaced with the nearest orthogonal
    matrix. To efficiently orthogonalize each update, we use a Newton-Schulz iteration, which has
    the advantage that it can be stably run in bfloat16 on the GPU.

    Some warnings:
    - This optimizer assumes that all parameters passed in are 2D.
    - It should not be used for the embedding layer, the final fully connected layer, or any {0,1}-D
    parameters; those should all be optimized by a standard method (e.g., AdamW).
    - To use it with 4D convolutional filters, it works well to just flatten their last 3 dimensions.
    - We believe it is unlikely to work well for training with small batch size.
    - We believe it may not work well for finetuning pretrained models, but we haven't tested this.
    - We have not yet tried this optimizer for training scenarios larger than NanoGPT (124M).

    Arguments:
        lr: The learning rate used by the internal SGD.
        momentum: The momentum used by the internal SGD.
        nesterov: Whether to use Nesterov-style momentum in the internal SGD. (recommended)
        backend: The chosen backend for the orthogonalization step. (recommended: 'newtonschulz5')
        backend_steps: The number of iteration steps to use in the backend, if it is iterative.
    """
    def __init__(self, params, lr=0.02, momentum=0.95, nesterov=True,
                 backend='newtonschulz5', backend_steps=5):
        defaults = dict(lr=lr, momentum=momentum, nesterov=nesterov, backend=backend, backend_steps=backend_steps)
        super().__init__(params, defaults)

    def step(self):

        for group in self.param_groups:

            lr = group['lr']
            momentum = group['momentum']
            zeropower_backend = zeropower_backends[group['backend']]

            # generate weight updates in distributed fashion
            total_params = sum(p.numel() for p in group['params'])
            updates_flat = torch.zeros(total_params, device='cuda', dtype=torch.bfloat16)
            curr_idx = 0
            for i, p in enumerate(group['params']):
                # luckily this will perfectly distribute a transformer with multiple of 4 layers to 8 GPUs
                if i % int(os.environ['WORLD_SIZE']) == int(os.environ['RANK']):
                    g = p.grad
                    assert g is not None
                    state = self.state[p]
                    if 'momentum_buffer' not in state:
                        state['momentum_buffer'] = torch.zeros_like(g)
                    buf = state['momentum_buffer']
                    buf.mul_(momentum).add_(g)
                    if group['nesterov']:
                        g = g.add(buf, alpha=momentum)
                    g = zeropower_backend(g, steps=group['backend_steps'])
                    g *= max(1, g.size(0)/g.size(1))**0.5
                    updates_flat[curr_idx:curr_idx+p.numel()] = g.flatten()
                curr_idx += p.numel()

            # sync updates across devices. we are not memory-constrained so can do this simple deserialization
            dist.all_reduce(updates_flat, op=dist.ReduceOp.SUM)

            # deserialize and apply updates
            curr_idx = 0
            for p in group['params']:
                g = updates_flat[curr_idx:curr_idx+p.numel()].view_as(p.data).type_as(p.data)
                p.data.add_(g, alpha=-lr)
                curr_idx += p.numel()

# -----------------------------------------------------------------------------
# PyTorch nn.Module definitions for the GPT-2 model

class Rotary(torch.nn.Module):

    def __init__(self, dim, base=10000):
        super().__init__()
        self.inv_freq = 1.0 / (base ** (torch.arange(0, dim, 2).float() / dim))
        self.seq_len_cached = None
        self.cos_cached = None
        self.sin_cached = None

    def forward(self, x):
        seq_len = x.shape[1]
        if seq_len != self.seq_len_cached:
            self.seq_len_cached = seq_len
            t = torch.arange(seq_len, device=x.device).type_as(self.inv_freq)
            freqs = torch.outer(t, self.inv_freq).to(x.device)
            self.cos_cached = freqs.cos().bfloat16()
            self.sin_cached = freqs.sin().bfloat16()
        return self.cos_cached[None, :, None, :], self.sin_cached[None, :, None, :]

def apply_rotary_emb(x, cos, sin):
    assert x.ndim == 4 # multihead attention
    d = x.shape[3]//2
    x1 = x[..., :d]
    x2 = x[..., d:]
    y1 = x1 * cos + x2 * sin
    y2 = x1 * (-sin) + x2 * cos
    return torch.cat([y1, y2], 3).type_as(x)

class CastedLinear(nn.Linear):
    def forward(self, x):
        return F.linear(x, self.weight.to(x.dtype))

class CausalSelfAttention(nn.Module):

    def __init__(self, config, layer_id: int):
        super().__init__()
        self.layer_id = layer_id
        self.n_head = config.n_head
        self.n_embd = config.n_embd
        self.head_dim = self.n_embd // self.n_head
        assert self.n_embd % self.n_head == 0
        self.c_q = CastedLinear(self.n_embd, self.n_embd, bias=False)
        self.c_k = CastedLinear(self.n_embd, self.n_embd, bias=False)
        self.c_v = CastedLinear(self.n_embd, self.n_embd, bias=False)
        # output projection
        self.c_proj = CastedLinear(self.n_embd, self.n_embd, bias=False)
        self.c_proj.weight.data.zero_() # zero init suggested by @Grad62304977
        self.rotary = Rotary(self.head_dim)
        self.lamb = nn.Parameter(torch.tensor(0.5)) # @Grad62304977

    def forward(self, x: torch.Tensor, v1: torch.Tensor | None = None, v_weighted_skip: torch.Tensor | None = None):
        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)
        q = self.c_q(x).view(B, T, self.n_head, self.head_dim)
        k = self.c_k(x).view(B, T, self.n_head, self.head_dim)
        v = self.c_v(x).view(B, T, self.n_head, self.head_dim)
        if v1 is None:
            v1 = v # v needs to be accessed by subsequent blocks
        v = (1 - self.lamb) * v + self.lamb * v1.view_as(v) # @Grad62304977
        if v_weighted_skip is not None:
            v = v + v_weighted_skip.view_as(v)
        cos, sin = self.rotary(q)
        q, k = F.rms_norm(q, (q.size(-1),)), F.rms_norm(k, (k.size(-1),)) # QK norm suggested by @Grad62304977
        q, k = apply_rotary_emb(q, cos, sin), apply_rotary_emb(k, cos, sin)
        y = F.scaled_dot_product_attention(q.transpose(1, 2), k.transpose(1, 2), v.transpose(1, 2), is_causal=True)
        y = y.transpose(1, 2).contiguous().view_as(x) # re-assemble all head outputs side by side
        y = self.c_proj(y)
        return y, v1, v

class MLP(nn.Module):

    def __init__(self, config):
        super().__init__()
        self.c_fc    = CastedLinear(config.n_embd, 4 * config.n_embd, bias=False)
        self.c_proj  = CastedLinear(4 * config.n_embd, config.n_embd, bias=False)
        self.c_proj.weight.data.zero_() # zero init suggested by @Grad62304977

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.c_fc(x)
        x = F.relu(x).square() # https://arxiv.org/abs/2109.08668v2; ~1-2% better than GELU; suggested by @SKYLINEZ007 and @Grad62304977
        x = self.c_proj(x)
        return x

class Block(nn.Module):

    def __init__(self, config, layer_id: int):
        super().__init__()
        self.layer_id = layer_id
        self.attn = CausalSelfAttention(config, layer_id)
        self.mlp = MLP(config)
        self.lambdas = nn.Parameter(torch.tensor([1., 0.]))

    def forward(self, x, v1, x0, v_weighted_skip=None):
        x = self.lambdas[0] * x + self.lambdas[1] * x0
        x1, v1, v = self.attn(F.rms_norm(x, (x.size(-1),)), v1, v_weighted_skip)
        x = x + x1
        x = x + self.mlp(F.rms_norm(x, (x.size(-1),)))
        return x, v1, v

# -----------------------------------------------------------------------------
# The main GPT-2 model

@dataclass
class GPTConfig:
    vocab_size : int = 50304
    n_layer : int = 12
    n_head : int = 6 # head dim 128 suggested by @Grad62304977
    n_embd : int = 768

class GPT(nn.Module):

    def __init__(self, config):
        super().__init__()
        self.config = config

        self.transformer = nn.ModuleDict(dict(
            wte = nn.Embedding(config.vocab_size, config.n_embd),
            h = nn.ModuleList([Block(config, layer_id) for layer_id in range(config.n_layer)]),
        ))

        # U-net design by @brendanh0gan
        self.encoder_layers = config.n_layer // 2 # Half of the layers for encoder
        self.decoder_layers = config.n_layer - self.encoder_layers # Remaining for decoder
        # Add learnable skip connection weights for decoder layers
        self.skip_weights = nn.Parameter(torch.ones(self.decoder_layers))
        self.v_skip_weights = nn.Parameter(torch.ones(self.decoder_layers))

        self.lm_head = CastedLinear(config.n_embd, config.vocab_size, bias=False)
        self.lm_head.weight.data.zero_() # @Grad62304977

    def forward(self, idx, target):

        # forward the GPT model itself
        x = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)
        x = F.rms_norm(x, (x.size(-1),)) # @Grad62304977
        x0 = x
        v1 = None

        # Store outputs for U-Net skip connections
        skip_connections = []
        v_skip_connections = []

        # Encoder pass - process only the first half of the blocks
        for i in range(self.encoder_layers):
            x, v1, v = self.transformer.h[i](x, v1, x0)
            skip_connections.append(x)  # Store the output for skip connections
            v_skip_connections.append(v)

        # Decoder pass - process the remaining blocks with weighted skip connections
        for i in range(self.decoder_layers):
            skip_connection = skip_connections.pop()  # Get the corresponding encoder output
            v_skip_connection = v_skip_connections.pop()
            # Apply learnable weight to skip connection
            weighted_skip = self.skip_weights[i] * skip_connection
            v_weighted_skip = self.v_skip_weights[i] * v_skip_connection
            x, v1, v = self.transformer.h[self.encoder_layers + i](x + weighted_skip, v1, x0, v_weighted_skip)

        x = F.rms_norm(x, (x.size(-1),))
        logits = self.lm_head(x)
        logits = 30 * torch.tanh(logits / 30) # @Grad62304977
        logits = logits.float()
        loss = F.cross_entropy(logits.view(-1, logits.size(-1)), target.view(-1))
        return loss.float()

# -----------------------------------------------------------------------------
# Our own simple Distributed Data Loader

def _peek_data_shard(filename):
    # only reads the header, returns header data
    with open(filename, "rb") as f:
        # first read the header, which is 256 int32 integers (4 bytes each)
        header = np.frombuffer(f.read(256*4), dtype=np.int32)
    if header[0] != 20240520:
        print("ERROR: magic number mismatch in the data .bin file!")
        print("---> HINT: Are you passing in a correct file with --input_bin?")
        print("---> HINT: Dataset encoding changed recently, re-run data prepro or refer again to README")
        print("---> HINT: For example re-run: `python dev/data/tinyshakespeare.py`, then re-try")
        exit(1)
    assert header[1] == 1, "unsupported version"
    ntok = header[2] # number of tokens (claimed)
    return ntok # for now just return the number of tokens

def _load_data_shard(filename):
    with open(filename, "rb") as f:
        # first read the header, which is 256 int32 integers (4 bytes each)
        header = np.frombuffer(f.read(256*4), dtype=np.int32)
        assert header[0] == 20240520, "magic number mismatch in the data .bin file"
        assert header[1] == 1, "unsupported version"
        ntok = header[2] # number of tokens (claimed)
        # the rest of it are tokens, stored as uint16
        tokens = np.frombuffer(f.read(), dtype=np.uint16)
    assert len(tokens) == ntok, "number of tokens read does not match header?"
    return tokens

class DistributedDataLoader:
    def __init__(self, filename_pattern, B, T, process_rank, num_processes):
        self.process_rank = process_rank
        self.num_processes = num_processes
        self.B = B
        self.T = T

        # glob files that match the pattern
        self.files = sorted(glob.glob(filename_pattern))
        assert len(self.files) > 0, f"did not find any files that match the pattern {filename_pattern}"

        # load and validate all data shards, count number of tokens in total
        ntok_total = 0
        for fname in self.files:
            shard_ntok = _peek_data_shard(fname)
            assert shard_ntok >= num_processes * B * T + 1
            ntok_total += int(shard_ntok)
        self.ntok_total = ntok_total

        # kick things off
        self.reset()

    def reset(self):
        self.current_shard = 0
        self.current_position = self.process_rank * self.B * self.T
        self.tokens = _load_data_shard(self.files[self.current_shard])

    def advance(self): # advance to next data shard
        self.current_shard = (self.current_shard + 1) % len(self.files)
        self.current_position = self.process_rank * self.B * self.T
        self.tokens = _load_data_shard(self.files[self.current_shard])

    def next_batch(self):
        B = self.B
        T = self.T
        buf = self.tokens[self.current_position : self.current_position+B*T+1]
        buf = torch.tensor(buf.astype(np.int32), dtype=torch.long)
        x = (buf[:-1]).view(B, T) # inputs
        y = (buf[1:]).view(B, T) # targets
        # advance current position and load next shard if necessary
        self.current_position += B * T * self.num_processes
        if self.current_position + (B * T * self.num_processes + 1) > len(self.tokens):
            self.advance()
        return x.cuda(), y.cuda()

# -----------------------------------------------------------------------------
# int main

@dataclass
class Hyperparameters:
    # data hyperparams
    input_bin : str = 'data/fineweb10B/fineweb_train_*.bin' # input .bin to train on
    input_val_bin : str = 'data/fineweb10B/fineweb_val_*.bin' # input .bin to eval validation loss on
    # optimization hyperparams
    batch_size : int = 8*64 # batch size, in sequences, across all devices
    device_batch_size : int = 64 # batch size, in sequences, per device
    sequence_length : int = 1024 # sequence length, in tokens
    num_iterations : int = 3000 # number of iterations to run
    warmup_iters : int = 0
    warmdown_iters : int = 900 # number of iterations of linear warmup/warmdown for triangular or trapezoidal schedule
    weight_decay : float = 0
    # evaluation and logging hyperparams
    val_loss_every : int = 125 # every how many steps to evaluate val loss? 0 for only at the end
    val_tokens : int = 10485760 # how many tokens of validation data? it's important to keep this fixed for consistent comparisons
    save_every : int = 0 # every how many steps to save the checkpoint? 0 for only at the end
args = Hyperparameters()

# set up DDP (distributed data parallel). torchrun sets this env variable
assert torch.cuda.is_available()
dist.init_process_group(backend='nccl')
ddp_rank = int(os.environ['RANK'])
ddp_local_rank = int(os.environ['LOCAL_RANK'])
ddp_world_size = int(os.environ['WORLD_SIZE'])
device = f'cuda:{ddp_local_rank}'
torch.cuda.set_device(device)
print(f"using device: {device}")
master_process = (ddp_rank == 0) # this process will do logging, checkpointing etc.

# convenience variables
B, T = args.device_batch_size, args.sequence_length
# calculate the number of steps to take in the val loop.
assert args.val_tokens % (B * T * ddp_world_size) == 0
val_steps = args.val_tokens // (B * T * ddp_world_size)
# calculate the steps of gradient accumulation required to attain the desired global batch size.
assert args.batch_size % (B * ddp_world_size) == 0
train_accumulation_steps = args.batch_size // (B * ddp_world_size)

# load tokens
train_loader = DistributedDataLoader(args.input_bin, B, T, ddp_rank, ddp_world_size)
val_loader = DistributedDataLoader(args.input_val_bin, B, T, ddp_rank, ddp_world_size)
if master_process:
    print(f"Training DataLoader: total number of tokens: {train_loader.ntok_total} across {len(train_loader.files)} files")
    print(f"Validation DataLoader: total number of tokens: {val_loader.ntok_total} across {len(val_loader.files)} files")
x, y = train_loader.next_batch()

# there are only 50257 unique GPT-2 tokens; we extend to nearest multiple of 128 for efficiency. suggested to me by @Grad62304977.
# this originates from Karpathy's experiments.
num_vocab = 50304
model = GPT(GPTConfig(vocab_size=num_vocab, n_layer=12, n_head=6, n_embd=768))
model = model.cuda().bfloat16()
for m in model.modules():
    if isinstance(m, CastedLinear):
        m.float()

if hasattr(config, "coordinate_descent_tuning"):
    config.coordinate_descent_tuning = True # suggested by @Chillee
model = torch.compile(model)
# here we wrap model into DDP container
model = DDP(model, device_ids=[ddp_local_rank])
raw_model = model.module # always contains the "raw" unwrapped model

# CUDNN attention is ~4ms faster than Flash, but doesn't get selected by default in PyTorch 2.5.1
from torch.backends.cuda import enable_cudnn_sdp, enable_flash_sdp, enable_math_sdp, enable_mem_efficient_sdp
enable_cudnn_sdp(True)
enable_flash_sdp(False)
enable_mem_efficient_sdp(False)
enable_math_sdp(False)

# init the optimizer(s)
optimizer1 = torch.optim.Adam([raw_model.transformer.wte.weight], lr=0.9,   betas=(0.9, 0.95), fused=True)
optimizer2 = torch.optim.Adam([raw_model.lm_head.weight],         lr=0.012, betas=(0.9, 0.95), fused=True)
params = list(raw_model.transformer.h.parameters())
matrix_params = [p for p in params if p.ndim == 2]
scalar_params = [p for p in params if p.ndim < 2]+[raw_model.skip_weights]+[raw_model.v_skip_weights]
optimizer3 = Muon(matrix_params, lr=0.06, momentum=0.95)
optimizer4 = torch.optim.Adam(scalar_params, lr=0.08, betas=(0.9, 0.95), fused=True) # note that this learning rate is neither sensitive nor tuned
optimizers = [optimizer1, optimizer2, optimizer3, optimizer4]
# learning rate decay scheduler (linear warmup and warmdown)
def get_lr(it):
    assert it <= args.num_iterations
    # 1) linear warmup for warmup_iters steps
    if it < args.warmup_iters:
        return (it+1) / args.warmup_iters
    # 2) constant lr for a while
    elif it < args.num_iterations - args.warmdown_iters:
        return 1.0
    # 3) linear warmdown
    else:
        decay_ratio = (args.num_iterations - it) / args.warmdown_iters
        return decay_ratio
schedulers = [torch.optim.lr_scheduler.LambdaLR(opt, get_lr) for opt in optimizers]

# begin logging
if master_process:
    run_id = str(uuid.uuid4())
    logdir = 'logs/%s/' % run_id
    os.makedirs(logdir, exist_ok=True)
    logfile = 'logs/%s.txt' % run_id
    print(f"{logfile = }")
    # create the log file
    with open(logfile, "w") as f:
        # begin the log by printing this file (the Python code)
        f.write('='*100 + '\n')
        f.write(code)
        f.write('='*100 + '\n')
        # log information about the hardware/software environment this is running on
        # and print the full `nvidia-smi` to file
        f.write(f"Running pytorch {torch.version.__version__} compiled for CUDA {torch.version.cuda}\nnvidia-smi:\n")
        import subprocess
        result = subprocess.run(['nvidia-smi'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        f.write(f'{result.stdout}\n')
        f.write('='*100 + '\n')

training_time_ms = 0
# start the clock
torch.cuda.synchronize()
t0 = time.time()
# begin training
train_loader.reset()
for step in range(args.num_iterations + 1):
    last_step = (step == args.num_iterations)
    # This effectively ignores timing first 10 steps, which are slower for weird reasons.
    # Alternately, and slightly more correctly in terms of benchmarking, we could do 10
    # steps with dummy data first, and then re-initialize the model and reset the loader.
    if step == 10:
        training_time_ms = 0
        t0 = time.time()
    timed_steps = float('nan') if step <= 11 else (step - 10) + 1 # <= 11 to avoid bug in val

    # once in a while evaluate the validation dataset
    if (last_step or (args.val_loss_every > 0 and step % args.val_loss_every == 0)):
        # stop the clock
        torch.cuda.synchronize()
        training_time_ms += 1000 * (time.time() - t0)
        # run validation batches
        model.eval()
        val_loader.reset()
        val_loss = 0.0
        for _ in range(val_steps):
            with torch.no_grad():
                x_val, y_val = val_loader.next_batch()
                val_loss += model(x_val, y_val)
        dist.all_reduce(val_loss, op=dist.ReduceOp.AVG)
        val_loss /= val_steps
        # log val loss to console and to logfile
        if master_process:
            print(f'step:{step}/{args.num_iterations} val_loss:{val_loss:.4f} train_time:{training_time_ms:.0f}ms step_avg:{training_time_ms/(timed_steps-1):.2f}ms')
            with open(logfile, "a") as f:
                f.write(f'step:{step}/{args.num_iterations} val_loss:{val_loss:.4f} train_time:{training_time_ms:.0f}ms step_avg:{training_time_ms/(timed_steps-1):.2f}ms\n')
        # log lambdas
        if master_process:
            skip_weights_str = str(model.module.skip_weights)
            v_skip_weights_str = str(model.module.v_skip_weights)
            print(f"{skip_weights_str = }")
            print(f"{v_skip_weights_str = }")
        # start the clock again
        torch.cuda.synchronize()
        t0 = time.time()

    if master_process and (last_step or (args.save_every > 0 and step % args.save_every == 0)):
        # stop the clock
        torch.cuda.synchronize()
        training_time_ms += 1000 * (time.time() - t0)
        # save the state of the training process
        log = dict(step=step, code=code, model=raw_model.state_dict(), optimizers=[opt.state_dict() for opt in optimizers])
        torch.save(log, 'logs/%s/state_step%06d.pt' % (run_id, step))
        # start the clock again
        torch.cuda.synchronize()
        t0 = time.time()

    # bit confusing: we want to make sure to eval on 0th iteration
    # but also after the very last iteration. so we loop for step <= num_iterations
    # instead of just < num_iterations (one extra due to <=), only to do
    # the validation/sampling one last time, and then we break right here as we're done.
    if last_step:
        break

    # --------------- TRAINING SECTION BEGIN -----------------
    model.train()
    for i in range(1, train_accumulation_steps+1):
        # forward pass
        loss = model(x, y)
        train_loss = loss.detach()
        # advance the dataset for the next batch
        x, y = train_loader.next_batch()
        # backward pass
        if i < train_accumulation_steps:
            with model.no_sync(): # there's no need to sync gradients every accumulation step
                loss.backward()
        else:
            loss.backward() # just sync on the last step
    for p in model.parameters():
        p.grad /= train_accumulation_steps
    # momentum warmup for Muon
    frac = min(step/500, 1)
    optimizer3.param_groups[0]['momentum'] = (1 - frac) * 0.85 + frac * 0.95
    # step the optimizers and schedulers
    for opt, sched in zip(optimizers, schedulers):
        opt.step()
        sched.step()
    # null the gradients
    model.zero_grad(set_to_none=True)
    # --------------- TRAINING SECTION END -------------------
    # everything that follows now is just diagnostics, prints, logging, etc.

    #dist.all_reduce(train_loss, op=dist.ReduceOp.AVG) # all-reducing the training loss would be more correct in terms of logging, but slower
    if master_process:
        approx_time = training_time_ms + 1000 * (time.time() - t0)
        print(f"step:{step+1}/{args.num_iterations} train_loss:{train_loss.item():.4f} train_time:{approx_time:.0f}ms step_avg:{approx_time/timed_steps:.2f}ms")
        with open(logfile, "a") as f:
            f.write(f"step:{step+1}/{args.num_iterations} train_loss:{train_loss.item():.4f} train_time:{approx_time:.0f}ms step_avg:{approx_time/timed_steps:.2f}ms\n")

if master_process:
    print(f"peak memory consumption: {torch.cuda.max_memory_allocated() // 1024 // 1024} MiB")
    with open(logfile, "a") as f:
        f.write(f"peak memory consumption: {torch.cuda.max_memory_allocated() // 1024 // 1024} MiB")

# -------------------------------------------------------------------------
# clean up nice
dist.destroy_process_group()
====================================================================================================
Running pytorch 2.5.1+cu124 compiled for CUDA 12.4
nvidia-smi:
Fri Nov 15 14:35:10 2024       
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 550.127.05             Driver Version: 550.127.05     CUDA Version: 12.4     |
|-----------------------------------------+------------------------+----------------------+
| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  NVIDIA A100-SXM4-80GB          On  |   00000000:0A:00.0 Off |                    0 |
| N/A   34C    P0             73W /  400W |    3337MiB /  81920MiB |      0%      Default |
|                                         |                        |             Disabled |
+-----------------------------------------+------------------------+----------------------+
|   1  NVIDIA A100-SXM4-80GB          On  |   00000000:84:00.0 Off |                    0 |
| N/A   38C    P0             73W /  400W |    3407MiB /  81920MiB |      7%      Default |
|                                         |                        |             Disabled |
+-----------------------------------------+------------------------+----------------------+
|   2  NVIDIA A100-SXM4-80GB          On  |   00000000:C1:00.0 Off |                    0 |
| N/A   34C    P0             75W /  400W |    3481MiB /  81920MiB |      0%      Default |
|                                         |                        |             Disabled |
+-----------------------------------------+------------------------+----------------------+
|   3  NVIDIA A100-SXM4-80GB          On  |   00000000:C4:00.0 Off |                    0 |
| N/A   46C    P0             81W /  400W |    3337MiB /  81920MiB |     12%      Default |
|                                         |                        |             Disabled |
+-----------------------------------------+------------------------+----------------------+
                                                                                         
+-----------------------------------------------------------------------------------------+
| Processes:                                                                              |
|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
|        ID   ID                                                               Usage      |
|=========================================================================================|
+-----------------------------------------------------------------------------------------+

====================================================================================================
step:0/3000 val_loss:10.8258 train_time:326ms step_avg:nanms
step:1/3000 train_loss:10.8258 train_time:13838ms step_avg:nanms
step:2/3000 train_loss:10.2589 train_time:14488ms step_avg:nanms
step:3/3000 train_loss:8.4132 train_time:15153ms step_avg:nanms
step:4/3000 train_loss:7.8918 train_time:15822ms step_avg:nanms
step:5/3000 train_loss:8.1700 train_time:16490ms step_avg:nanms
step:6/3000 train_loss:7.6664 train_time:17160ms step_avg:nanms
step:7/3000 train_loss:7.9090 train_time:17828ms step_avg:nanms
step:8/3000 train_loss:7.2918 train_time:18498ms step_avg:nanms
step:9/3000 train_loss:7.0042 train_time:19168ms step_avg:nanms
step:10/3000 train_loss:6.8671 train_time:19839ms step_avg:nanms
step:11/3000 train_loss:6.8522 train_time:660ms step_avg:nanms
step:12/3000 train_loss:6.7866 train_time:1330ms step_avg:nanms
step:13/3000 train_loss:6.6540 train_time:2000ms step_avg:666.69ms
step:14/3000 train_loss:6.5493 train_time:2671ms step_avg:667.68ms
step:15/3000 train_loss:6.5014 train_time:3341ms step_avg:668.11ms
step:16/3000 train_loss:6.4937 train_time:4012ms step_avg:668.59ms
step:17/3000 train_loss:6.5309 train_time:4684ms step_avg:669.15ms
step:18/3000 train_loss:6.3246 train_time:5356ms step_avg:669.55ms
step:19/3000 train_loss:6.3000 train_time:6028ms step_avg:669.79ms
step:20/3000 train_loss:6.0429 train_time:6701ms step_avg:670.11ms
step:21/3000 train_loss:6.3279 train_time:7374ms step_avg:670.37ms
step:22/3000 train_loss:6.5959 train_time:8046ms step_avg:670.47ms
step:23/3000 train_loss:6.2122 train_time:8719ms step_avg:670.68ms
step:24/3000 train_loss:6.3523 train_time:9391ms step_avg:670.78ms
step:25/3000 train_loss:6.0512 train_time:10066ms step_avg:671.04ms
step:26/3000 train_loss:5.9864 train_time:10738ms step_avg:671.10ms
step:27/3000 train_loss:6.1575 train_time:11411ms step_avg:671.25ms
step:28/3000 train_loss:5.8110 train_time:12084ms step_avg:671.31ms
step:29/3000 train_loss:6.0707 train_time:12757ms step_avg:671.41ms
step:30/3000 train_loss:5.8858 train_time:13430ms step_avg:671.51ms
step:31/3000 train_loss:5.8689 train_time:14104ms step_avg:671.60ms
step:32/3000 train_loss:5.7186 train_time:14777ms step_avg:671.68ms
step:33/3000 train_loss:5.9989 train_time:15452ms step_avg:671.81ms
step:34/3000 train_loss:5.9070 train_time:16126ms step_avg:671.90ms
step:35/3000 train_loss:6.0762 train_time:16799ms step_avg:671.97ms
step:36/3000 train_loss:6.0089 train_time:17473ms step_avg:672.03ms
step:37/3000 train_loss:5.8833 train_time:18147ms step_avg:672.11ms
step:38/3000 train_loss:5.7403 train_time:18820ms step_avg:672.15ms
step:39/3000 train_loss:5.7482 train_time:19495ms step_avg:672.24ms
step:40/3000 train_loss:5.6669 train_time:20170ms step_avg:672.32ms
step:41/3000 train_loss:5.6573 train_time:20843ms step_avg:672.37ms
step:42/3000 train_loss:5.5535 train_time:21518ms step_avg:672.45ms
step:43/3000 train_loss:5.6681 train_time:22192ms step_avg:672.49ms
step:44/3000 train_loss:5.6194 train_time:22867ms step_avg:672.56ms
step:45/3000 train_loss:5.7565 train_time:23541ms step_avg:672.59ms
step:46/3000 train_loss:5.5742 train_time:24216ms step_avg:672.66ms
step:47/3000 train_loss:5.4406 train_time:24892ms step_avg:672.74ms
step:48/3000 train_loss:5.6282 train_time:25569ms step_avg:672.87ms
step:49/3000 train_loss:5.5297 train_time:26244ms step_avg:672.92ms
step:50/3000 train_loss:5.6412 train_time:26919ms step_avg:672.97ms
step:51/3000 train_loss:5.5103 train_time:27594ms step_avg:673.03ms
step:52/3000 train_loss:5.3615 train_time:28269ms step_avg:673.07ms
step:53/3000 train_loss:5.4991 train_time:28944ms step_avg:673.12ms
step:54/3000 train_loss:5.3617 train_time:29618ms step_avg:673.14ms
step:55/3000 train_loss:5.7535 train_time:30293ms step_avg:673.17ms
step:56/3000 train_loss:5.3951 train_time:30968ms step_avg:673.23ms
step:57/3000 train_loss:5.2530 train_time:31643ms step_avg:673.25ms
step:58/3000 train_loss:5.3758 train_time:32318ms step_avg:673.29ms
step:59/3000 train_loss:5.3583 train_time:32994ms step_avg:673.34ms
step:60/3000 train_loss:5.4621 train_time:33670ms step_avg:673.41ms
step:61/3000 train_loss:5.1967 train_time:34346ms step_avg:673.46ms
step:62/3000 train_loss:5.3227 train_time:35022ms step_avg:673.49ms
step:63/3000 train_loss:5.2977 train_time:35695ms step_avg:673.49ms
step:64/3000 train_loss:5.2719 train_time:36372ms step_avg:673.55ms
step:65/3000 train_loss:5.1240 train_time:37045ms step_avg:673.55ms
step:66/3000 train_loss:5.2662 train_time:37721ms step_avg:673.59ms
step:67/3000 train_loss:5.1092 train_time:38395ms step_avg:673.60ms
step:68/3000 train_loss:5.4343 train_time:39070ms step_avg:673.62ms
step:69/3000 train_loss:5.0333 train_time:39745ms step_avg:673.64ms
step:70/3000 train_loss:5.1249 train_time:40420ms step_avg:673.67ms
step:71/3000 train_loss:5.2982 train_time:41094ms step_avg:673.68ms
step:72/3000 train_loss:5.2250 train_time:41769ms step_avg:673.70ms
step:73/3000 train_loss:5.0922 train_time:42444ms step_avg:673.72ms
step:74/3000 train_loss:5.2308 train_time:43119ms step_avg:673.74ms
step:75/3000 train_loss:5.2203 train_time:43794ms step_avg:673.76ms
step:76/3000 train_loss:5.1274 train_time:44470ms step_avg:673.79ms
step:77/3000 train_loss:5.2285 train_time:45145ms step_avg:673.81ms
step:78/3000 train_loss:5.4026 train_time:45821ms step_avg:673.84ms
step:79/3000 train_loss:5.1426 train_time:46495ms step_avg:673.84ms
step:80/3000 train_loss:5.1825 train_time:47169ms step_avg:673.84ms
step:81/3000 train_loss:4.9461 train_time:47844ms step_avg:673.86ms
step:82/3000 train_loss:5.1364 train_time:48518ms step_avg:673.86ms
step:83/3000 train_loss:5.0841 train_time:49192ms step_avg:673.86ms
step:84/3000 train_loss:5.0750 train_time:49867ms step_avg:673.88ms
step:85/3000 train_loss:4.9244 train_time:50543ms step_avg:673.91ms
step:86/3000 train_loss:5.1191 train_time:51219ms step_avg:673.93ms
step:87/3000 train_loss:5.0285 train_time:51894ms step_avg:673.94ms
step:88/3000 train_loss:5.0614 train_time:52568ms step_avg:673.95ms
step:89/3000 train_loss:5.0136 train_time:53243ms step_avg:673.96ms
step:90/3000 train_loss:4.9513 train_time:53917ms step_avg:673.96ms
step:91/3000 train_loss:4.9409 train_time:54591ms step_avg:673.97ms
step:92/3000 train_loss:5.0785 train_time:55264ms step_avg:673.95ms
step:93/3000 train_loss:4.9137 train_time:55939ms step_avg:673.96ms
step:94/3000 train_loss:4.9260 train_time:56612ms step_avg:673.96ms
step:95/3000 train_loss:4.9546 train_time:57288ms step_avg:673.97ms
step:96/3000 train_loss:4.8528 train_time:57963ms step_avg:673.99ms
step:97/3000 train_loss:4.9082 train_time:58638ms step_avg:674.00ms
step:98/3000 train_loss:4.8353 train_time:59312ms step_avg:674.00ms
step:99/3000 train_loss:4.9332 train_time:59988ms step_avg:674.02ms
step:100/3000 train_loss:4.9151 train_time:60662ms step_avg:674.02ms
step:101/3000 train_loss:4.8160 train_time:61338ms step_avg:674.05ms
step:102/3000 train_loss:4.9266 train_time:62013ms step_avg:674.05ms
step:103/3000 train_loss:4.8122 train_time:62688ms step_avg:674.06ms
step:104/3000 train_loss:4.7561 train_time:63361ms step_avg:674.06ms
step:105/3000 train_loss:4.7955 train_time:64037ms step_avg:674.07ms
step:106/3000 train_loss:4.8457 train_time:64711ms step_avg:674.08ms
step:107/3000 train_loss:4.7639 train_time:65385ms step_avg:674.07ms
step:108/3000 train_loss:4.5752 train_time:66059ms step_avg:674.07ms
step:109/3000 train_loss:4.7099 train_time:66735ms step_avg:674.09ms
step:110/3000 train_loss:4.7064 train_time:67408ms step_avg:674.08ms
step:111/3000 train_loss:4.6454 train_time:68082ms step_avg:674.08ms
step:112/3000 train_loss:4.7740 train_time:68758ms step_avg:674.10ms
step:113/3000 train_loss:4.6889 train_time:69432ms step_avg:674.09ms
step:114/3000 train_loss:4.5836 train_time:70105ms step_avg:674.09ms
step:115/3000 train_loss:4.7212 train_time:70780ms step_avg:674.10ms
step:116/3000 train_loss:4.6371 train_time:71454ms step_avg:674.10ms
step:117/3000 train_loss:4.5557 train_time:72128ms step_avg:674.10ms
step:118/3000 train_loss:4.7778 train_time:72803ms step_avg:674.10ms
step:119/3000 train_loss:4.6502 train_time:73477ms step_avg:674.10ms
step:120/3000 train_loss:4.5324 train_time:74152ms step_avg:674.11ms
step:121/3000 train_loss:4.4829 train_time:74826ms step_avg:674.11ms
step:122/3000 train_loss:4.6257 train_time:75501ms step_avg:674.11ms
step:123/3000 train_loss:4.4456 train_time:76175ms step_avg:674.11ms
step:124/3000 train_loss:4.7502 train_time:76849ms step_avg:674.11ms
step:125/3000 train_loss:4.6236 train_time:77524ms step_avg:674.12ms
step:125/3000 val_loss:4.5770 train_time:77536ms step_avg:674.22ms
step:126/3000 train_loss:4.5735 train_time:78199ms step_avg:674.13ms
step:127/3000 train_loss:4.6199 train_time:78873ms step_avg:674.13ms
step:128/3000 train_loss:4.5297 train_time:79549ms step_avg:674.14ms
step:129/3000 train_loss:4.8334 train_time:80223ms step_avg:674.14ms
step:130/3000 train_loss:4.5042 train_time:80898ms step_avg:674.15ms
step:131/3000 train_loss:4.5530 train_time:81574ms step_avg:674.16ms
step:132/3000 train_loss:4.4910 train_time:82247ms step_avg:674.16ms
step:133/3000 train_loss:4.6007 train_time:82921ms step_avg:674.16ms
step:134/3000 train_loss:4.4056 train_time:83597ms step_avg:674.17ms
step:135/3000 train_loss:4.5829 train_time:84270ms step_avg:674.16ms
step:136/3000 train_loss:4.3507 train_time:84945ms step_avg:674.17ms
step:137/3000 train_loss:4.5201 train_time:85620ms step_avg:674.17ms
step:138/3000 train_loss:4.4184 train_time:86294ms step_avg:674.17ms
step:139/3000 train_loss:4.5211 train_time:86968ms step_avg:674.17ms
step:140/3000 train_loss:4.5960 train_time:87642ms step_avg:674.17ms
step:141/3000 train_loss:4.4630 train_time:88316ms step_avg:674.17ms
step:142/3000 train_loss:4.4388 train_time:88989ms step_avg:674.16ms
step:143/3000 train_loss:4.3925 train_time:89664ms step_avg:674.16ms
step:144/3000 train_loss:4.5030 train_time:90338ms step_avg:674.17ms
step:145/3000 train_loss:4.4260 train_time:91013ms step_avg:674.17ms
step:146/3000 train_loss:4.3129 train_time:91687ms step_avg:674.17ms
step:147/3000 train_loss:4.4504 train_time:92362ms step_avg:674.17ms
step:148/3000 train_loss:4.5018 train_time:93036ms step_avg:674.17ms
step:149/3000 train_loss:4.4552 train_time:93711ms step_avg:674.18ms
step:150/3000 train_loss:4.5628 train_time:94385ms step_avg:674.18ms
step:151/3000 train_loss:4.3833 train_time:95059ms step_avg:674.18ms
step:152/3000 train_loss:4.3984 train_time:95733ms step_avg:674.18ms
step:153/3000 train_loss:4.4873 train_time:96408ms step_avg:674.18ms
step:154/3000 train_loss:4.4718 train_time:97083ms step_avg:674.19ms
step:155/3000 train_loss:4.3868 train_time:97758ms step_avg:674.19ms
step:156/3000 train_loss:4.4593 train_time:98432ms step_avg:674.19ms
step:157/3000 train_loss:4.5223 train_time:99106ms step_avg:674.19ms
step:158/3000 train_loss:4.3493 train_time:99780ms step_avg:674.19ms
step:159/3000 train_loss:4.4245 train_time:100455ms step_avg:674.20ms
step:160/3000 train_loss:4.2363 train_time:101129ms step_avg:674.20ms
step:161/3000 train_loss:4.4810 train_time:101804ms step_avg:674.20ms
step:162/3000 train_loss:4.4668 train_time:102478ms step_avg:674.20ms
step:163/3000 train_loss:4.4491 train_time:103152ms step_avg:674.20ms
step:164/3000 train_loss:4.3120 train_time:103826ms step_avg:674.20ms
step:165/3000 train_loss:4.3876 train_time:104501ms step_avg:674.20ms
step:166/3000 train_loss:4.4611 train_time:105174ms step_avg:674.20ms
step:167/3000 train_loss:4.3042 train_time:105849ms step_avg:674.19ms
step:168/3000 train_loss:4.3753 train_time:106523ms step_avg:674.19ms
step:169/3000 train_loss:4.2843 train_time:107197ms step_avg:674.19ms
step:170/3000 train_loss:4.1482 train_time:107871ms step_avg:674.19ms
step:171/3000 train_loss:4.3057 train_time:108545ms step_avg:674.19ms
step:172/3000 train_loss:4.3315 train_time:109220ms step_avg:674.20ms
step:173/3000 train_loss:4.3629 train_time:109894ms step_avg:674.20ms
step:174/3000 train_loss:4.5276 train_time:110569ms step_avg:674.20ms
step:175/3000 train_loss:4.3532 train_time:111242ms step_avg:674.19ms
step:176/3000 train_loss:4.2068 train_time:111917ms step_avg:674.20ms
step:177/3000 train_loss:4.1853 train_time:112590ms step_avg:674.19ms
step:178/3000 train_loss:4.2895 train_time:113264ms step_avg:674.19ms
step:179/3000 train_loss:4.2436 train_time:113938ms step_avg:674.19ms
step:180/3000 train_loss:4.2234 train_time:114613ms step_avg:674.20ms
step:181/3000 train_loss:4.3972 train_time:115289ms step_avg:674.20ms
step:182/3000 train_loss:4.2654 train_time:115962ms step_avg:674.20ms
step:183/3000 train_loss:4.2398 train_time:116635ms step_avg:674.19ms
step:184/3000 train_loss:4.2454 train_time:117310ms step_avg:674.20ms
step:185/3000 train_loss:4.3248 train_time:117984ms step_avg:674.19ms
step:186/3000 train_loss:4.2890 train_time:118658ms step_avg:674.20ms
step:187/3000 train_loss:4.3529 train_time:119332ms step_avg:674.19ms
step:188/3000 train_loss:4.2875 train_time:120006ms step_avg:674.19ms
step:189/3000 train_loss:4.2052 train_time:120680ms step_avg:674.19ms
step:190/3000 train_loss:4.3151 train_time:121374ms step_avg:674.30ms
step:191/3000 train_loss:4.3865 train_time:122237ms step_avg:675.34ms
step:192/3000 train_loss:4.1907 train_time:122910ms step_avg:675.33ms
step:193/3000 train_loss:4.2575 train_time:123583ms step_avg:675.32ms
step:194/3000 train_loss:4.2194 train_time:124258ms step_avg:675.31ms
step:195/3000 train_loss:4.1874 train_time:124931ms step_avg:675.30ms
step:196/3000 train_loss:4.1836 train_time:125605ms step_avg:675.29ms
step:197/3000 train_loss:4.2149 train_time:126279ms step_avg:675.29ms
step:198/3000 train_loss:4.1165 train_time:126954ms step_avg:675.29ms
step:199/3000 train_loss:4.3582 train_time:127627ms step_avg:675.28ms
step:200/3000 train_loss:4.2851 train_time:128302ms step_avg:675.27ms
step:201/3000 train_loss:5.0261 train_time:128975ms step_avg:675.26ms
step:202/3000 train_loss:4.4829 train_time:129650ms step_avg:675.26ms
step:203/3000 train_loss:4.2507 train_time:130325ms step_avg:675.26ms
step:204/3000 train_loss:4.1754 train_time:130998ms step_avg:675.25ms
step:205/3000 train_loss:4.2262 train_time:131672ms step_avg:675.24ms
step:206/3000 train_loss:4.1949 train_time:132348ms step_avg:675.24ms
step:207/3000 train_loss:4.1904 train_time:133022ms step_avg:675.24ms
step:208/3000 train_loss:4.1366 train_time:133696ms step_avg:675.23ms
step:209/3000 train_loss:4.3087 train_time:134372ms step_avg:675.24ms
step:210/3000 train_loss:4.1284 train_time:135045ms step_avg:675.23ms
step:211/3000 train_loss:4.2224 train_time:135720ms step_avg:675.22ms
step:212/3000 train_loss:4.2149 train_time:136394ms step_avg:675.22ms
step:213/3000 train_loss:4.1590 train_time:137068ms step_avg:675.21ms
step:214/3000 train_loss:4.1167 train_time:137742ms step_avg:675.20ms
step:215/3000 train_loss:4.2624 train_time:138415ms step_avg:675.20ms
step:216/3000 train_loss:4.1875 train_time:139091ms step_avg:675.20ms
step:217/3000 train_loss:4.1766 train_time:139765ms step_avg:675.19ms
step:218/3000 train_loss:4.2034 train_time:140439ms step_avg:675.19ms
step:219/3000 train_loss:4.1056 train_time:141113ms step_avg:675.18ms
step:220/3000 train_loss:4.2220 train_time:141787ms step_avg:675.18ms
step:221/3000 train_loss:4.1272 train_time:142461ms step_avg:675.17ms
step:222/3000 train_loss:4.2102 train_time:143135ms step_avg:675.17ms
step:223/3000 train_loss:4.1486 train_time:143809ms step_avg:675.16ms
step:224/3000 train_loss:4.1417 train_time:144484ms step_avg:675.16ms
step:225/3000 train_loss:4.1301 train_time:145158ms step_avg:675.15ms
step:226/3000 train_loss:4.1597 train_time:145832ms step_avg:675.15ms
step:227/3000 train_loss:4.1488 train_time:146507ms step_avg:675.15ms
step:228/3000 train_loss:4.0667 train_time:147181ms step_avg:675.14ms
step:229/3000 train_loss:4.2982 train_time:147854ms step_avg:675.13ms
step:230/3000 train_loss:4.1557 train_time:148528ms step_avg:675.13ms
step:231/3000 train_loss:4.0366 train_time:149202ms step_avg:675.12ms
step:232/3000 train_loss:4.2611 train_time:149876ms step_avg:675.12ms
step:233/3000 train_loss:4.0899 train_time:150550ms step_avg:675.11ms
step:234/3000 train_loss:4.1256 train_time:151225ms step_avg:675.11ms
step:235/3000 train_loss:4.2791 train_time:151900ms step_avg:675.11ms
step:236/3000 train_loss:4.1832 train_time:152574ms step_avg:675.11ms
step:237/3000 train_loss:4.2663 train_time:153248ms step_avg:675.10ms
step:238/3000 train_loss:4.2130 train_time:153922ms step_avg:675.10ms
step:239/3000 train_loss:4.1925 train_time:154596ms step_avg:675.09ms
step:240/3000 train_loss:4.1709 train_time:155269ms step_avg:675.08ms
step:241/3000 train_loss:4.3588 train_time:155943ms step_avg:675.08ms
step:242/3000 train_loss:4.1846 train_time:156617ms step_avg:675.07ms
step:243/3000 train_loss:4.5262 train_time:157291ms step_avg:675.07ms
step:244/3000 train_loss:4.1436 train_time:157964ms step_avg:675.06ms
step:245/3000 train_loss:4.1633 train_time:158638ms step_avg:675.05ms
step:246/3000 train_loss:4.1955 train_time:159312ms step_avg:675.05ms
step:247/3000 train_loss:4.0957 train_time:159986ms step_avg:675.05ms
step:248/3000 train_loss:4.1013 train_time:160661ms step_avg:675.05ms
step:249/3000 train_loss:4.0342 train_time:161335ms step_avg:675.04ms
step:250/3000 train_loss:4.2098 train_time:162009ms step_avg:675.04ms
step:250/3000 val_loss:4.1081 train_time:162021ms step_avg:675.09ms
step:251/3000 train_loss:4.0905 train_time:162683ms step_avg:675.03ms
step:252/3000 train_loss:4.0070 train_time:163358ms step_avg:675.03ms
step:253/3000 train_loss:4.0464 train_time:164032ms step_avg:675.03ms
step:254/3000 train_loss:4.1136 train_time:164705ms step_avg:675.02ms
step:255/3000 train_loss:4.0467 train_time:165378ms step_avg:675.01ms
step:256/3000 train_loss:3.9843 train_time:166053ms step_avg:675.01ms
step:257/3000 train_loss:4.0667 train_time:166726ms step_avg:675.01ms
step:258/3000 train_loss:4.1964 train_time:167401ms step_avg:675.00ms
step:259/3000 train_loss:4.0012 train_time:168073ms step_avg:674.99ms
step:260/3000 train_loss:4.1091 train_time:168748ms step_avg:674.99ms
step:261/3000 train_loss:4.0536 train_time:169423ms step_avg:674.99ms
step:262/3000 train_loss:4.0797 train_time:170097ms step_avg:674.99ms
step:263/3000 train_loss:4.1453 train_time:170771ms step_avg:674.99ms
step:264/3000 train_loss:4.1919 train_time:171445ms step_avg:674.98ms
step:265/3000 train_loss:4.5506 train_time:172119ms step_avg:674.98ms
step:266/3000 train_loss:4.0798 train_time:172793ms step_avg:674.97ms
step:267/3000 train_loss:4.2758 train_time:173468ms step_avg:674.97ms
step:268/3000 train_loss:4.0260 train_time:174142ms step_avg:674.97ms
step:269/3000 train_loss:4.0410 train_time:174815ms step_avg:674.96ms
step:270/3000 train_loss:4.1461 train_time:175490ms step_avg:674.96ms
step:271/3000 train_loss:4.1979 train_time:176163ms step_avg:674.95ms
step:272/3000 train_loss:4.0810 train_time:176838ms step_avg:674.95ms
step:273/3000 train_loss:4.0314 train_time:177512ms step_avg:674.95ms
step:274/3000 train_loss:4.0344 train_time:178186ms step_avg:674.95ms
step:275/3000 train_loss:4.0099 train_time:178860ms step_avg:674.94ms
step:276/3000 train_loss:4.1270 train_time:179536ms step_avg:674.95ms
step:277/3000 train_loss:4.1485 train_time:180209ms step_avg:674.94ms
step:278/3000 train_loss:3.9244 train_time:180885ms step_avg:674.95ms
step:279/3000 train_loss:4.2419 train_time:181559ms step_avg:674.94ms
step:280/3000 train_loss:4.0907 train_time:182234ms step_avg:674.94ms
step:281/3000 train_loss:4.0967 train_time:182907ms step_avg:674.93ms
step:282/3000 train_loss:4.0522 train_time:183583ms step_avg:674.94ms
step:283/3000 train_loss:4.2595 train_time:184256ms step_avg:674.93ms
step:284/3000 train_loss:4.0011 train_time:184930ms step_avg:674.93ms
step:285/3000 train_loss:3.9785 train_time:185604ms step_avg:674.92ms
step:286/3000 train_loss:4.1596 train_time:186278ms step_avg:674.92ms
step:287/3000 train_loss:4.0861 train_time:186953ms step_avg:674.92ms
step:288/3000 train_loss:4.1131 train_time:187625ms step_avg:674.91ms
step:289/3000 train_loss:4.1561 train_time:188300ms step_avg:674.91ms
step:290/3000 train_loss:4.1464 train_time:188974ms step_avg:674.91ms
step:291/3000 train_loss:3.9790 train_time:189647ms step_avg:674.90ms
step:292/3000 train_loss:3.9522 train_time:190322ms step_avg:674.90ms
step:293/3000 train_loss:4.1508 train_time:190996ms step_avg:674.90ms
step:294/3000 train_loss:3.9542 train_time:191669ms step_avg:674.89ms
step:295/3000 train_loss:4.2421 train_time:192343ms step_avg:674.89ms
step:296/3000 train_loss:4.1359 train_time:193017ms step_avg:674.89ms
step:297/3000 train_loss:3.9530 train_time:193692ms step_avg:674.88ms
step:298/3000 train_loss:4.0725 train_time:194366ms step_avg:674.88ms
step:299/3000 train_loss:3.9800 train_time:195041ms step_avg:674.88ms
step:300/3000 train_loss:4.1733 train_time:195715ms step_avg:674.88ms
step:301/3000 train_loss:3.9530 train_time:196389ms step_avg:674.88ms
step:302/3000 train_loss:4.0787 train_time:197063ms step_avg:674.87ms
step:303/3000 train_loss:4.0053 train_time:197737ms step_avg:674.87ms
step:304/3000 train_loss:4.0116 train_time:198411ms step_avg:674.87ms
step:305/3000 train_loss:4.0080 train_time:199085ms step_avg:674.86ms
step:306/3000 train_loss:4.1145 train_time:199758ms step_avg:674.86ms
step:307/3000 train_loss:4.0473 train_time:200433ms step_avg:674.86ms
step:308/3000 train_loss:3.9516 train_time:201107ms step_avg:674.86ms
step:309/3000 train_loss:4.1253 train_time:201781ms step_avg:674.85ms
step:310/3000 train_loss:3.9881 train_time:202454ms step_avg:674.85ms
step:311/3000 train_loss:4.0591 train_time:203129ms step_avg:674.85ms
step:312/3000 train_loss:4.0510 train_time:203802ms step_avg:674.84ms
step:313/3000 train_loss:3.9578 train_time:204476ms step_avg:674.84ms
step:314/3000 train_loss:4.0369 train_time:205151ms step_avg:674.84ms
step:315/3000 train_loss:4.0356 train_time:205824ms step_avg:674.83ms
step:316/3000 train_loss:3.7778 train_time:206498ms step_avg:674.83ms
step:317/3000 train_loss:4.0203 train_time:207172ms step_avg:674.83ms
step:318/3000 train_loss:4.0143 train_time:207845ms step_avg:674.82ms
step:319/3000 train_loss:3.9282 train_time:208519ms step_avg:674.82ms
step:320/3000 train_loss:3.9642 train_time:209193ms step_avg:674.82ms
step:321/3000 train_loss:4.0019 train_time:209866ms step_avg:674.81ms
step:322/3000 train_loss:4.0164 train_time:210540ms step_avg:674.81ms
step:323/3000 train_loss:3.8858 train_time:211214ms step_avg:674.81ms
step:324/3000 train_loss:3.9804 train_time:211889ms step_avg:674.80ms
step:325/3000 train_loss:4.0271 train_time:212563ms step_avg:674.80ms
step:326/3000 train_loss:4.0502 train_time:213238ms step_avg:674.80ms
step:327/3000 train_loss:4.0018 train_time:213911ms step_avg:674.80ms
step:328/3000 train_loss:4.2676 train_time:214585ms step_avg:674.80ms
step:329/3000 train_loss:4.0406 train_time:215260ms step_avg:674.80ms
step:330/3000 train_loss:4.0777 train_time:215935ms step_avg:674.80ms
step:331/3000 train_loss:3.9454 train_time:216608ms step_avg:674.79ms
step:332/3000 train_loss:4.5183 train_time:217284ms step_avg:674.79ms
step:333/3000 train_loss:3.9393 train_time:217958ms step_avg:674.79ms
step:334/3000 train_loss:3.8527 train_time:218634ms step_avg:674.80ms
step:335/3000 train_loss:4.0139 train_time:219308ms step_avg:674.79ms
step:336/3000 train_loss:4.0348 train_time:219981ms step_avg:674.79ms
step:337/3000 train_loss:4.0295 train_time:220656ms step_avg:674.79ms
step:338/3000 train_loss:4.0059 train_time:221330ms step_avg:674.79ms
step:339/3000 train_loss:4.0563 train_time:222004ms step_avg:674.78ms
step:340/3000 train_loss:3.9247 train_time:222678ms step_avg:674.78ms
step:341/3000 train_loss:3.9120 train_time:223351ms step_avg:674.78ms
step:342/3000 train_loss:3.9290 train_time:224026ms step_avg:674.78ms
step:343/3000 train_loss:3.9704 train_time:224702ms step_avg:674.78ms
step:344/3000 train_loss:4.0633 train_time:225376ms step_avg:674.78ms
step:345/3000 train_loss:3.9891 train_time:226050ms step_avg:674.78ms
step:346/3000 train_loss:3.9582 train_time:226726ms step_avg:674.78ms
step:347/3000 train_loss:4.0085 train_time:227400ms step_avg:674.78ms
step:348/3000 train_loss:3.9288 train_time:228075ms step_avg:674.78ms
step:349/3000 train_loss:3.9294 train_time:228750ms step_avg:674.78ms
step:350/3000 train_loss:4.0078 train_time:229424ms step_avg:674.78ms
step:351/3000 train_loss:4.2356 train_time:230099ms step_avg:674.78ms
step:352/3000 train_loss:3.8777 train_time:230774ms step_avg:674.78ms
step:353/3000 train_loss:3.9264 train_time:231448ms step_avg:674.78ms
step:354/3000 train_loss:3.9286 train_time:232122ms step_avg:674.77ms
step:355/3000 train_loss:3.8368 train_time:232797ms step_avg:674.77ms
step:356/3000 train_loss:3.9712 train_time:233470ms step_avg:674.77ms
step:357/3000 train_loss:3.8908 train_time:234143ms step_avg:674.76ms
step:358/3000 train_loss:4.0195 train_time:234817ms step_avg:674.76ms
step:359/3000 train_loss:3.9920 train_time:235491ms step_avg:674.76ms
step:360/3000 train_loss:3.9141 train_time:236165ms step_avg:674.76ms
step:361/3000 train_loss:4.1774 train_time:236839ms step_avg:674.76ms
step:362/3000 train_loss:4.1596 train_time:237513ms step_avg:674.75ms
step:363/3000 train_loss:3.9768 train_time:238187ms step_avg:674.75ms
step:364/3000 train_loss:3.8714 train_time:238860ms step_avg:674.75ms
step:365/3000 train_loss:4.0473 train_time:239535ms step_avg:674.75ms
step:366/3000 train_loss:3.8833 train_time:240208ms step_avg:674.74ms
step:367/3000 train_loss:3.9769 train_time:240883ms step_avg:674.74ms
step:368/3000 train_loss:3.9082 train_time:241557ms step_avg:674.74ms
step:369/3000 train_loss:3.9925 train_time:242231ms step_avg:674.74ms
step:370/3000 train_loss:3.9714 train_time:242906ms step_avg:674.74ms
step:371/3000 train_loss:3.7785 train_time:243580ms step_avg:674.74ms
step:372/3000 train_loss:3.9002 train_time:244255ms step_avg:674.74ms
step:373/3000 train_loss:3.9626 train_time:244929ms step_avg:674.74ms
step:374/3000 train_loss:3.9168 train_time:245603ms step_avg:674.73ms
step:375/3000 train_loss:4.0056 train_time:246279ms step_avg:674.74ms
step:375/3000 val_loss:3.9406 train_time:246290ms step_avg:674.77ms
step:376/3000 train_loss:3.9172 train_time:246953ms step_avg:674.74ms
step:377/3000 train_loss:3.8114 train_time:247628ms step_avg:674.74ms
step:378/3000 train_loss:3.3898 train_time:248302ms step_avg:674.73ms
step:379/3000 train_loss:3.7825 train_time:248977ms step_avg:674.73ms
step:380/3000 train_loss:3.7948 train_time:249651ms step_avg:674.73ms
step:381/3000 train_loss:3.9033 train_time:250339ms step_avg:674.77ms
